Object 클래스
- java.lang.Object, 모든 클래스의 최상위 클래스
- 모든 클래스는 Object클래스의 메소드를 사용할 수 있고, 일부 메소드를 override해서 사용할 수도 있음
- Object 클래스가 들어있는 java.lang 패키지는 컴파일러에 의해 자동으로 import됨
-

 toString()
- 객체의 해시코드 출력
- (클래스명@해시코드, getClass(), getName() + '@' + Integer.toHexString(hashCode()))
- 객체의 정보를 문자열 형태로 표현하고자 할 때 override를 자주 하는 편

equals()
- 객체의 값(==) 연산

hashCode()
- JVM이 부여한 코드값
- 객체가 저장된 가상머신의 주소를 10진수로 반환

clone()
- 객체의 복사본을 만듬
- clone()은 객체를 복제할 때 private 필드도 복제할 수 있기 떄문에 은닉화에 위배


상속
- 특정 클래스를 구성할 때 기존 클래스의 데이터와 메소드를 부모 클래스에서 그대로 물려받아 중복적인
  코드를 줄이는 것
- 하나의 변수 타입으로 여러 종류의 객체를 의미하는 추상화된 방식의 프로그램을 가능하게 해줌

* 상속성
- 상위 개념의 특징을 하위 개념이 물려받는 것
- 재사용으로 인해 코드를 줄임
- 객체지향 프로그래밍의 하이라이트!

* 다형성
- 부모클래스에서 물려받은 가상함수를 자식 클래스 내에서 오버라이팅 되어 사용하는 것
- 클래스 내부에 동일한 이름의 오퍼레이션을 여러개 정의하는것.

자바에서 상속을 하는 방법

    접근제어자 class 클래스명 extends 부모클래스명{
        클래스 설계
        ...
    }

오버라이딩
- 부모 클래스에 있는 필드 또는 메소드를 자식 클래스가 재정의 하는 것

instanceof 연산자
- 참조변수가 참조하고 있는 인스턴스(객체)의 실제 타입을 알아보기 위해 사용하는 연산자
- instanceof 왼쪽에는 참조변수, 오른쪽에는 타입(클래스명)이 피연산자로 위치
- 연산의 결과는 boolean 값으로 반환(true : 형 변환이 가능)

문제.
과일 구입 프로그램을 만들어보자.
(단, 과일 클래스를 상속받아 각 과일 이름별 클래스를 생성하고 과일저장은 10개까지)

메뉴를 선택하세요(1. 사과구입 2.바나나구입 3.오렌지구입 4.구입목록 5.과일검색 6.종료)
1
사과를 구입했습니다.
2
바나나를 구입했습니다
4
***** 구입한 과일 *****
사과 : 1000원, 빨강, 서울
바나나 : 1500원, 노랑, 제주도
...
5
검색할 과일을 선택하세요.(1.사과 2.바나나 3.오렌지)
1
사과 : 1000원, 빨강, 서울
6
프로그램을 종료합니다.


클래스 Fruit(부모클래스)
    name : 과일이름
    price : 가격
    color : 색상
    from : 원산지

클래스 Apple
클래스 Banana
클래스 Orange

장바구니 배열

접근 제어자
- 외부에 공개되는 수준을 의미
- public, protected, default, private
    public : 모든 외부에서 직접 접근하거나 호출
    protected : 현재 클래스와 동일한 패키지거나 다른 패키지더라도 상속시 접근하거나 호출
    default : 현재 클래스와 동일한 패키지 내에서만 접근하거나 호출(접근 제어자를 쓰지 않을 경우 default)
    private : 현재 클래스의 {} 바깥쪽에서는 절대 접근하거나 호출할 수 없음

클래스의 접근제한
- public, default만 사용 가능
- public인 경우 외부에 클래스를 노출, default는 현재 패키지에서만 접근할 수 있게 함

필드의 접근 제한
- public, protected, default, private 모두 사용 가능
- 일반적으로 private, public static으로 선언하는 것이 일반적

메소드의 접근 제한
- public, protected, default, private 모두 사용 가능
- 추상 메소드의 형태로 메소드를 만들 때 private으로 선언할 수 없음


패키지
- 클래스 파일들을 체계적으로 관리하도록 사용하는 디렉토리 개념

사용자가 패키지를 만드는 형태
    com.회사명.프로젝트명
    예) com.koreait.kakaotalk

* 패키지의 맨 뒤는 주로 패키지 안에 있는 클래스들의 역할로 작성되는 경우가 많음
    com.koreait.kakaotalk.network


static
- 모든 객체가 공유한다는 의미
- static이 붙은 변수는 클래스 변수
    (static이 붙지 않은 변수는 인스턴스 변수)
- 메모리에 우선 로드되므로 속도가 빠름(시작할때는 느림)
- 메모리가 회수되지 않기 때문에 주의

1. 변수에 적용
    모든 객체가 변수를 공용으로 사용
2. 블록에 적용
    같은 객체가 여러개 만들어지더라도 단 한번만 실행되는 코드블록을 만듬
3. 메소드에 적용
    객체를 사용하지 않고 클래스.메소드 이름으로 접근하여 사용
    메모리에 먼저 올라가기 때문에 바로 사용 가능!!

과제.
아래 용어에 대해 조사하고 예제를 만들어보자.

- 상속 : 상속 방법 (class 클래스(자식) extends 클래스(부모))
        상속받는 클래스를 (자식 클래스, 하위 클래스, 서브 클래스)
        상속을 해주는 클래스를 (부모 클래스, 상위 클래스, 슈퍼 클래스)
        자식 클래스는 부모 클래스로부터 메소드와 필드를 물려받아 사용
        자식 클래스가 더 다양한 기능이 가능하므로 자식 클래스로 인스턴스를 생성하는 것이 효율적

        장점 : 중복된 코드를 줄일 수 있고, 유지 보수가 편리하며, 통일성이 있고 다형성을 구현


- 접근 제어자 : 외부로부터 데이터를 보호하기 위해서 사용


- super키워드 : super 키워드는 부모 클래스로부터 상속받은 필드나 메소드를 자식 클래스에서 참조하는 데 사용하는 참조 변수
               super.메소드명();
               super.필드명;

- this 키워드 :
1) 자기 자신의 메모리를 카리킨다.
this.필드명

2) 생성자에서 다른 생성자를 호출할 경우 사용한다.
-매개 변수가 있는 생성자 2개를 생성한 후 매개 변수가 없는 생성자에 this 키워드를 이용하여 값을 넣을 경우 매개 변수가 있는 생성자를 참조하여
-메인 함수에서 생성자를 호출할 때 해당 값이 자동으로 대입
this(매개변수);

3) 인스턴스 자신의 주소를 반환할 때 사용한다.

- 생성자 :  new 연산자를 통해서 인스턴스를 생성할 때 반드시 호출이 되고 제일 먼저 실행되는 일종의 메소드(하지만 메소드와는 다르다.)이다.
           생성자는 인스턴스 변수(필드 값 등)를 초기화 시키는 역할을 한다.
           기본생성자 : (public) 클래스명(){

                       }
           매개변수를 갖는 생성자 : (public} 클래스명(매개변수){

                                 }


- 오버로딩  : 1개의 클래스에서 동일한 이름의 메소드 또는 생성자를 여러개 정의하는 것
            동일한 이름을 갖고 매개변수의 자료형, 개수, 순서를 다르게 하여 선언해야 한다.
            오버로딩을 하는 이유는 동일한 기능의 메서드를 정의할 때 외부로부터 다양한 입력값(매개값)을 받기 위해서 사용

- 오버라이딩 : 부모 클래스의 메소드를 자식 클래스에서 재정의함
             자식 클래스가 부모 클래스를 상속하여 자식한테 없는 메소드를 호출하면 부모클래스에 가서 해당 메소드를 찾게 된다.
             만약 부모 클래스의 메소드를 자식클래스에서 동일한 이름으로 다시 재정의 하면 부모클래스의 메소드를 찾지 않고 자식 클래스의 메소드를 호출한다.
             부모클래스와 자식클래스의 타입을 따를 수 없지만, 자식클래스와 자식클래스에 나온 객체가 부모클래스의 타입을 따를 수 있다.
